#多线程

#####进程和线程的区别
一个程序至少有一个进程,一个进程至少有一个线程.\
进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。\
进程是系统进行资源分配和调度的一个独立单位.\
线程是进程的一个实体,是CPU调度和分派的基本单位
####lock原理


####lock和synchronized两者的区别？
```
1.性能不一致：资源竞争激励的情况下，lock性能会比synchronize好，竞争不激励的情况下，synchronize比lock性能好。
2.锁机制不一样：synchronize是在JVM层面实现的，系统会监控锁的释放与否。lock是代码实现的，
    需要手动释放，在finally块中释放。可以采用非阻塞的方式获取锁。
3.用法不一样：synchronize可以用在代码块上，方法上。lock通过代码实现，有更精确的线程语义。


synchronized锁住的是括号里的对象，而不是代码。对于非static的synchronized方法，锁的就是对象本身也就是this。
当synchronized锁住一个对象后，别的线程如果也想拿到这个对象的锁，就必须等待这个线程执行完成释放锁，
才能再次给对象加锁，这样才达到线程同步的目的。即使两个不同的代码段，都要锁同一个对象，那么这两个代码段也不能在多线程环境下同时运行。

所以我们在用synchronized关键字的时候，能缩小代码段的范围就尽量缩小，能在代码段上加同步就不要再整个方法上加同步。
这叫减小锁的粒度，使代码更大程度的并发
```
#### synchronized 和 static synchronized区别
````
在同一个对像中synchronized (this) 中的this是对像的锁

如果synchronized中的this加锁后，另一个线程要等待synchronized方法中的this解锁，获取到this锁才能向下执行
总结：一个对像中的所有synchronized方法是同步执行的，因为使用的是this锁    两个对像同时执行synchronized方法是不会同步的
因为synchronized的锁是对像自已，当有一个方法锁定后其它方法要等待第一个方法解锁后 获取this的锁 

static synchronized方法，static方法可以直接类名加方法名调用，方法中无法使用this，
    所以它锁的不是this，而是类的Class对象，所以，static synchronized方法也相当于全局锁，相当于锁住了代码段。
总结：static synchronized 所有对像同步执行这个方法,因为使用的是.class锁 

````
####volatile关键字使用规则
volatile提供内存可见性和禁止内存重排序\
volatile使用场景：\
1.对变量的写操作不依赖当前值，如多线程下执行a++，是无法通过volatile保证结果准确性的\
2.该变量没有包含在具有其他变量的不变式中
####多次start一个线程会怎么样
第二次调用start()方法的时候，线程可能处于终止或者其他（非NEW）状态，但是不论如何，都是不可以再次启动的
####线程有哪些状态  线程生命周期
``````
线程生命周期    新建，就绪，阻塞，等待，计时等待，终止

新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。
就绪（RUNNABLE），表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。
    在其他一些分析中，会额外区分一种状态RUNNING，但是从Java API的角度，并不能表示出来。
阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitor lock。
    比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。
等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，
    发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，
    然后通过类似notify等动作，通知消费线程可以继续工作了。Thread.join()也会令线程进入等待状态。
计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本
终止（TERMINATED）
``````
####Thread和Runnable的区别和联系
一是直接继承Thread类，二是实现Runnable接口
Thread实现了Runnable接口并进行了扩展，我们通常拿来进行比较只是写法上的比较，
而Thread和Runnable的实质是实现的关系
效果上没区别，写法上的区别而已。
####synchronized和ReentrantLock的区别
````
    synchronized同步锁 
         synchronized属于悲观锁，直接对区域或者对象加锁，性能稳定，可以使用大部分场景。
    ReentrantLock可重入锁（Lock接口） 
        1. 相对于synchronized更加灵活，可以控制加锁和放锁的位置
        2. 可以使用Condition来操作线程，进行线程之间的通信
        3.  核心类AbstractQueuedSynchronizer，通过构造一个基于阻塞的CLH队列容纳所有的阻塞线程，
            而对该队列的操作均通过Lock-Free（CAS）操作，但对已经获得锁的线程而言，ReentrantLock实现了偏向锁的功能。
    ReentrantReadWriteLock可重入读写锁（ReadWriteLock接口） 
         1. 相对于ReentrantLock，对于大量的读操作，读和读之间不会加锁，只有存在写时才会加锁，但是这个锁是悲观锁
         2. ReentrantReadWriteLock实现了读写锁的功能
         3. ReentrantReadWriteLock是ReadWriteLock接口的实现类。ReadWriteLock接口的核心方法是readLock()，writeLock()。
            实现了并发读、互斥写。但读锁会阻塞写锁，是悲观锁的策略。
    StampedLock戳锁 
        1.  ReentrantReadWriteLock虽然解决了大量读取的效率问题，但是，由于实现的是悲观锁，当读取很多时，
            读取和读取之间又没有锁，写操作将无法竞争到锁，就会导致写线程饥饿。所以就需要对读取进行乐观锁处理。
        2.  StampedLock加入了乐观读锁，不会排斥写入
        3.  当并发量大且读远大于写的情况下最快的的是StampedLock锁
        
    StampedLock控制锁有三种模式（排它写，悲观读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，
        锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问。
````
####synchronized锁普通方法和锁静态方法
1.对象锁钥匙只能有一把才能互斥，才能保证共享变量的唯一性\
2.在静态方法上的锁，和 实例方法上的锁，默认不是同样的，如果同步需要制定两把锁一样。\
3.关于同一个类的方法上的锁，来自于调用该方法的对象，如果调用该方法的对象是相同的，那么锁必然相同，否则就不相同。
    比如 new A().x() 和 new A().x(),对象不同，锁不同，如果A的单利的，就能互斥。\
4.静态方法加锁，能和所有其他静态方法加锁的 进行互斥\
5.静态方法加锁，和xx.class 锁效果一样，直接属于类的
####死锁的原理及排查方法
互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，\
        其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。\
不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。\
请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。\
循环等待条件：:若干进程之间形成一种头尾相接的循环等待资源关系。 
####常用的线程池有几种？这几种线程池之间有什么区别和联系

````
newCachedThreadPool
    创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
    这种类型的线程池特点是：
        工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger.MAX_VALUE),
newFixedThreadPool
    创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中
FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。
    但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源
newSingleThreadExecutor
    创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，
    保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行
newScheduleThreadPool
    创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行
````
####线程池的实现原理是怎么样的

####什么样的场景该使用什么样的线程池比较合适
我们可以通过ThreadPoolExecutor来创建一个线程池

####synchronized的实现机制？
实现有两部分：monitor对象，线程，工作机制还是线程抢占对象使用权，
对象有自己的对象头，存储了对象的很多信息，其中有一个是标识被哪个线程持有，
对比AQS，线程从修改state，变为修改monitor的对象头，线程的等待区域动 AQS中的队列，变为monitor对象中的某个区域



####wait()和sleep()的区别
sleep来自Thread类，和wait来自Object类
调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁
sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU
sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒


####面试必备之乐观锁与悲观锁
```
悲观锁
    总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁
    （共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，
    比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
乐观锁
    总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，
    可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，
    其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，
像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。
    但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，
所以一般多写的场景下用悲观锁就比较合适。

CAS与synchronized的使用情景
简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），
synchronized适用于写比较多的情况下（多写场景，冲突一般较多）

对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；
而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。

```
















