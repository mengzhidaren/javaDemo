#TCP/IP
###### 七层OSI模型
▪ 应用层▪ 表示层▪ 会话层▪ 传输层▪ 网络层▪数据链路层▪物理层
######  五层OSI模型
▪ 应用层▪ 运输层▪ 网络层▪数据链路层▪物理层
````
应用层：任务是通过应用进程间的交互来完成特定的网络应用。
运输层：任务是负责向两个主机中进程之间的通信提供通用的数据传输服务。 应用层主要有两种协议： 
*传输控制协议TCP——提供面向连接的、可靠地数据传输服务，其数据传输的单位是报文段。 
*用户数据报协议UDP——-提供无连接的、尽最大努力交付的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报。 
网络层：负责为分组交换网上的不同主机提供通信服务。在发送数据的时候，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。
       分组也叫IP数据包或者数据报。所以，网络层也是把数据封装成数据报。
数据链路层：两台主机之间的数据传输，总是在一段一段的链路层上传送的，这就需要专门的数据链路层协议。
           当两个相邻节点之间传送数据时，数据链路层将网络层上交下来的IP数据报组装成帧。
````
######从我们在浏览器的地址栏输入http://blog.csdn.net/seu_calvin后回车，到我们看到该博客的主页，这中间经历了什么呢？
答:大概是经历了域名解析、TCP的三次握手、建立TCP连接后发起HTTP请求、服务器响应HTTP请求、浏览器解析html代码，
    同时请求html代码中的资源（如js、css、图片等）、最后浏览器对页面进行渲染并呈现给用户

######Socket原理
流套接字（streamsocket） ：基于 TCP协议，采用 流的方式 提供可靠的字节流服务\
数据报套接字(datagramsocket)：基于 UDP协议，采用 数据报文 提供数据打包发送的服务

######Socket 与 Http 对比
Socket属于传输层，因为 TCP / IP协议属于传输层，解决的是数据如何在网络中传输的问题\
HTTP协议 属于 应用层，解决的是如何包装数据\
1.Socket不是一种协议，而是一个编程调用接口（API），属于传输层（主要解决数据如何在网络中传输）\
2.即：通过Socket，我们才能在Andorid平台上通过 TCP/IP协议进行开发\
3.对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信\

######TCP三次握手
首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。
````
Client客户端A   Server服务端B
总结三次握手过程：

第一次握手：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；
第二次握手：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，
            并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；
第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，
            并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，
            完成三次握手，随后Client和Server就可以开始传输数据。

为什么A还要发送一次确认呢？可以二次握手吗？
答：主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误


````
######为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。
但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。
只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
######为什么A在TIME-WAIT状态必须等待2MSL的时间？
MSL最长报文段寿命Maximum Segment Lifetime，MSL=2\
1.保证A发送的最后一个ACK报文段能够到达B。\
2.防止“已失效的连接请求报文段”出现在本连接中。\
````
1）这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，
而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，
若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，
则B无法正常进入到CLOSED状态。
2）A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。
````

######为什么TCP是可靠的，UDP早不可靠的?为什么UDP比TCP快?
TCP/IP协议高，因为其拥有三次握手双向机制，这一机制保证校验了数据，保证了他的可靠性。
UDP就没有了，udp信息发出后,不验证是否到达对方,所以不可靠。
但是就速度来说，还是UDP协议更高，毕竟其无需重复返回验证，只是一次性的


######tcp的阻塞和超时处理机制等等
########TIME_WAIT 
time_wait状态产生的原因\
1）为实现TCP全双工连接的可靠释放\
2）为使旧的数据包在网络因过期而消失\

time_wait状态如何避免\
首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。\
在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。

######流量控制，拥塞控制 滑动窗口
所谓流量控制，主要是接收方传递信息给发送方，使其不要发送数据太快，是一种端到端的控制\

网络中的链路容量和交换结点中的缓存和处理机都有着工作的极限，当网络的需求超过它们的工作极限时，就出现了拥塞。
拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载

滑动窗口协议
1. “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”；
2. “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”



######http头里面的host有什么用url里面都有了为什么在头字段要有
http1.1协议要求必须加上host，主要是为同一服务器提供两个以上的站点服务。
比如www1.fucku.com和www2.fucku.com两个域名IP相同，由同一台服务器支持，服务器可以根据host域，分别提供不同的服务，
在客户端看来是两个完全不同的站点。


######Https的工作流程，原理
通过安全协议如SSL/TLS 来保证数据传输, SSL和TLS都是基于非对称加密算法，而RSA算法是非对称加密算法中的佼佼者。
Https是一种基于SSL/TLS的Http协议，所有的http数据都是在SSL/TLS协议封装之上传输的。

Https协议在Http协议的基础上，添加了SSL/TLS握手以及数据加密传输，也属于应用层协议。
——>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。
——>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS运行在TCP之上。所有传输的内容都经过加密,
    加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。
TLS/SSL中使用了非对称加密，对称加密以及HASH算法。
######HTTP1.0与2.0的区别
新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，
        要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，
        每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，
        HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。


######http协议了解多少，说说里面的协议头部有哪些字段?
http(超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议;http请求由三部分组成，分别是：请求行、消息报头、请求正文。
HTTP消息报头包括普通报头、请求报头、响应报头、实体报头
######https了解多少
HTTPS(全称：Hyper Text Transfer Protocol over Secure Socket Layer)，
是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
######HTTPS与HTTP的一些区别
HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。\
HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。\
HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\
HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。
######推送心跳包是TCP包还是UDP包或者HTTP包
心跳包的实现是调用了socket.sendUrgentData(0xFF)这句代码实现的，所以，当然是TCP包。
7 Http和Https的区别？
1）Https是ssl加密传输，Http是明文传输
2）Https是使用端口443，而Http使用80 
3）HttpsSSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比Http协议安全
4）Https协议需要到CA申请证书



######HttpClient和HttpURLConnection的区别 
在Android 2.2版本之前，HttpClient拥有较少的bug，因此使用它是最好的选择。
而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小







