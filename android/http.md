#TCP/IP
###### 七层OSI模型
▪ 应用层▪ 表示层▪ 会话层▪ 传输层▪ 网络层▪数据链路层▪物理层
######  五层OSI模型
▪ 应用层▪ 运输层▪ 网络层▪数据链路层▪物理层
````
应用层：任务是通过应用进程间的交互来完成特定的网络应用。
运输层：任务是负责向两个主机中进程之间的通信提供通用的数据传输服务。 应用层主要有两种协议： 
*传输控制协议TCP——提供面向连接的、可靠地数据传输服务，其数据传输的单位是报文段。 
*用户数据报协议UDP——-提供无连接的、尽最大努力交付的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报。 
网络层：负责为分组交换网上的不同主机提供通信服务。在发送数据的时候，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。
       分组也叫IP数据包或者数据报。所以，网络层也是把数据封装成数据报。
数据链路层：两台主机之间的数据传输，总是在一段一段的链路层上传送的，这就需要专门的数据链路层协议。
           当两个相邻节点之间传送数据时，数据链路层将网络层上交下来的IP数据报组装成帧。
````
###### HTTP之URL
````
HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接

schema://host[:port#]/path/.../[;url-params][?query-string][#anchor]
　　scheme 指定低层使用的协议(例如：http, https, ftp)
　　host HTTP服务器的IP地址或者域名
　　port# HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/
　　path 访问资源的路径
　　url-params 
　　query-string 发送给http服务器的数据
　　anchor- 锚

一个完整的URL包括以下几部分： 例如： http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name
1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。
  在"HTTP"后面的“//”为分隔符
2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用
3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口
4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”
5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，
            如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。
            本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名
6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分
7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。
           参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。



````
######URI和URL,URN的区别
```
URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。
    Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
    URI一般由三部组成：
        ①访问资源的命名机制
        ②存放资源的主机名
        ③资源自身的名称，由路径表示，着重强调于资源。
URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。
    URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上
    采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等
    URL一般由三部组成：
        ①协议(或称为服务方式)
        ②存有该资源的主机IP地址(有时也包括端口号)
        ③主机资源的具体地址。如目录和文件名等
URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。
    URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，
    每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，
    它命名资源但不指定如何定位资源
       在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。
       而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。
       在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。
       相反的是，URL类可以打开一个到达资源的流。 

```

###### 一次完整的HTTP请求所经历的7个步骤
```
一次完整的HTTP请求所经历的7个步骤
    HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：
        建立TCP连接->发送请求行->发送请求头->（到达服务器）发送状态行->发送响应头->发送响应数据->断TCP连接
    该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络
```
######从我们在浏览器的地址栏输入http://blog.csdn.net/seu_calvin后回车，到我们看到该博客的主页，这中间经历了什么呢？
```
答:大概是经历了域名解析、TCP的三次握手、建立TCP连接后发起HTTP请求、服务器响应HTTP请求、浏览器解析html代码，
    同时请求html代码中的资源（如js、css、图片等）、最后浏览器对页面进行渲染并呈现给用户
```
######http协议了解多少，说说里面的协议头部有哪些字段?
```
http(超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议;
    http请求由三部分组成，分别是：
        请求行、
        消息报头、
        请求正文。
HTTP消息报头包括
    普通报头、
    请求报头、
    响应报头、
    实体报头
```



#######  HTTP之请求消息Request
````
客户端发送一个HTTP请求到服务器的请求消息包括以下格式：
四个部分组成。
    请求行（request line）   包含请求方法、URI、HTTP版本信息
    请求头部（header） 
    空行
    请求数据
    
GET请求例子

GET /yyl.jpg HTTP/1.1
Host    img.mukewang.com
User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
Accept    image/webp,image/*,*/*;q=0.8
Referer    http://www.imooc.com/
Accept-Encoding    gzip, deflate, sdch
Accept-Language    zh-CN,zh;q=0.8

POST请求例子

POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley

第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息
第三部分：空行，请求头部后面的空行是必须的
第四部分：请求数据也叫主体，可以添加任意的其他数据。
````
#######  HTTP之响应消息Response
````
HTTP响应也由四个部分组成
    状态行    ：包含HTTP版本、状态码、状态码的原因短语
    消息报头
    空行
    响应正文
如下：
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。
第二部分：消息报头，用来说明客户端要使用的一些附加信息
第三部分：空行，消息报头后面的空行是必须的
第四部分：响应正文，服务器返回给客户端的文本信息。

````
####### 报头
````
1. 请求行   
格式为： Method Request-URI HTTP-Version 结尾符    
        结尾符一般用\r\n


2. 请求头
通用报头
既可以出现在请求报头，也可以出现在响应报头中
Date：表示消息产生的日期和时间
Connection：允许发送指定连接的选项，例如指定连接是连续的，或者指定“close”选项，通知服务器，在响应完成后，关闭连接
Cache-Control：用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），
               且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制）
公共头部字段说明
    Remote Address  请求的远程地址
    Request URL  请求的域名
    Request Method  页面请求的方式：GET/POST

Status Code
请求的返回状态
请求报头
请求报头通知服务器关于客户端求求的信息，典型的请求头有：
Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机
User-Agent：发送请求的浏览器类型、操作系统等信息
Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息  
Accept-Encoding：客户端可识别的数据编码
Accept-Language：表示浏览器所支持的语言类型
Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如这是为Keep-Alive则表示保持连接。
Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。
请求头字段说明
Accept 表示浏览器支持的 MIME 类型
Accept-Encoding 浏览器支持的压缩类型
Accept-Language 浏览器支持的语言类型，并且优先支持靠前的语言类型
Cache-Control 指定请求和响应遵循的缓存机制
Connection 当浏览器与服务器通信时对于长连接如何进行处理：close/keep-alive
Cookie 向服务器返回cookie，这些cookie是之前服务器发给浏览器的
Host 请求的服务器URL
Referer 该页面的来源URL
User-Agent 用户客户端的一些必要信息

ACCEPT
　　例子中的Accept字段是这样子的：Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8。
    意思是：浏览器支持的MIME类型分别是text/html、application/xhtml+xml、application/xml和/，优先顺序是它们从左到右的排列顺序。
    Accept表示浏览器支持的 MIME 类型；MIME的英文全称是 Multipurpose Internet Mail Extensions（多功能 Internet 邮件扩充服务），
          它是一种多用途网际邮件扩充协议，在1992年最早应用于电子邮件系统，但后来也应用到浏览器。
　　      text/html,application/xhtml+xml,application/xml 都是 MIME 类型，也可以称为媒体类型和内容类型，斜杠前面的是 type（类型）
          斜杠后面的是 subtype（子类型）；type 指定大的范围，subtype 是 type 中范围更明确的类型，即大类中的小类。
    　　Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；
　　      text/html表示 html 文档；
　　    Application：用于传输应用程序数据或者二进制数据；
　　      application/xhtml+xml表示 xhtml 文档；
　　      application/xml表示 xml 文档。
CACHE-CONTROL
　　Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会影响到另一个消息处理过程中的缓存处理过程。
 　　             请求时的缓存指令包括：no-cache, no-store, max-age, max-stale, min-fresh, only-if-cached。 　
 　               响应消息中的指令包括：public, private, no-cache, no-store, no-transform, must-revalidate, 
                                     proxy-revalidate, max-age。 
　　   各个指令的含义： 　　
　　      Public：指示响应可被任何缓存区缓存。
　　      Private：指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当前用户的部分响应消息，
                   此响应消息对于其他用户的请求无效。
　　      no-cache：指示请求或响应消息不能缓存
　　      no-store：用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。
　　      max-age：指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。
　　      min-fresh：指示客户机可以接收响应时间小于当前时间加上指定时间的响应。
　　      max-stale：指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。

响应报头
用于服务器传递自身信息的响应，常见的响应报头：
Location：用于重定向接受者到一个新的位置，常用在更换域名的时候
Server：包含可服务器用来处理请求的系统信息，与User-Agent请求报头是相对应的
实体报头
实体报头用来定于被传送资源的信息，既可以用于请求也可用于响应。请求和响应消息都可以传送一个实体，常见的实体报头为：
Content-Type：发送给接收者的实体正文的媒体类型
Content-Lenght：实体正文的长度
Content-Language：描述资源所用的自然语言，没有设置则该选项则认为实体内容将提供给所有的语言阅读
Content-Encoding：实体报头被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，
                  因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。
Last-Modified：实体报头用于指示资源的最后修改日期和时间
Expires：实体报头给出响应过期的日期和时间
返回头字段说明
Cache-Control 告诉浏览器或者其他客户，什么环境可以安全地缓存文档
Connection 当client和server通信时对于长链接如何进行处理
Content-Encoding 数据在传输过程中所使用的压缩编码方式
Content-Type 数据的类型
Date 数据从服务器发送的时间
Expires 应该在什么时候认为文档已经过期，从而不再缓存它？
Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置
Set-Cookie 设置和页面关联的cookie
Transfer-Encoding 数据传输的方式

3. 空行
http协议规定的格式，一般采用\r\n

4. 消息主体
一般用于http的post method。通过实体报头规定消息主体的格式内容、
例如: Content-Type=text/plain
     该实体报头规定了消息主体的数据是纯文本格式
常见的还有
    Content-Type=application/x-www-form-urlencoded，定义为Key=value格式
    Content-Type=application/json，定义为序列化为的json字符串
    Content-Type= multipart/form-data，定义为表单数据提交，
        multipart/form-data 该格式比较复杂，详细解释一下。
        1. 该格式是post的常见提交方式，也就是说是由post方法来组合实现的
        2. 使用该提交方法需要规定一个内容分割符用于分割请求体中的多个post的内容，如文件内容和文本内容自然需要分割开来，
           不然接收方就无法正常解析和还原这个文件了。具体的头信息如下：
            Content-Type: multipart/form-data; boundary=${bound} 
            其中${bound}是自定义的分隔符，一般情况用一长串不会和业务数据重复的字符串表示 ，例如9431149156168
        3. 分割符前面需要加上--
        4. 最后的分割符后面也需要加上—
        5. 所有的数据请求头和数据之间都用\r\n\r\n分开，两个数据间用 --${bound}\r\n分开
````

####### GET和POST请求的区别
````
1. GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变
    GET提交 : 请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&连接
    POST提交：POST方法是把提交的数据放在HTTP包的Body中.
2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。
    GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)对于其他浏览器其限制取决于操作系 统的支持。
    POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。
3、安全性
    POST的安全性要比GET的安全性高
4、Http get,post,soap协议都是在http上运行的
（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的
            查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全
（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，
            因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，
            其参数也是作为key/value对传输。
            但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。
（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式
           Content-type设置为: text/xml 任何数据都可以xml化。


或者：
get是从服务器上获取数据，post是向服务器传送数据。
get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP 的post机制，将表单内各个字段与其内容放置在HTML header内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。
对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。
get传送的数据量较小，因为受URL限制，不能大于2KB，但是效率高。
post传送的数据量较大，一般被默认为不受限制，所以上传文件时只能用post。但理论上，IIS4中最大量为80KB，IIS5中为100KB。
get安全性非常低，因为URL是可见的，可能会泄露私密信息，如密码等，post安全性较高。但是执行效率却比Post方法好。
get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。
post支持标准字符集，可以正确传递中文字符。
get请求可以被缓存，可以被收藏为书签，但 post 不行。
get请求会保留在浏览器的历史记录中，post 不会。
````




######http头里面的host有什么用url里面都有了为什么在头字段要有
```
http1.1协议要求必须加上host，主要是为同一服务器提供两个以上的站点服务。
比如www1.fucku.com和www2.fucku.com两个域名IP相同，由同一台服务器支持，服务器可以根据host域，分别提供不同的服务，
在客户端看来是两个完全不同的站点。
```


###### HTTP1.1版本新特性
默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断 - 管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应
断点续传 （实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输）

######Cookie和Session的区别
````
cookie数据存放在客户的浏览器上，session数据放在服务器上。
cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
       考虑到安全应当使用session。
session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
        考虑到减轻服务器性能方面，应当使用COOKIE。
单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
````
###### 缓存的实现原理
````
WEB缓存(cache)位于Web服务器和客户端之间。
缓存会根据请求保存输出内容的副本，例如html页面，图片，文件，当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，
    而不是向源服务器再次发送请求。
HTTP协议定义了相关的消息头来使WEB缓存尽可能好的工作。
1、缓存的优点
减少相应延迟：因为请求从缓存服务器（离客户端更近）而不是源服务器被相应，这个过程耗时更少，让web服务器看上去相应更快。
减少网络带宽消耗：当副本被重用时会减低客户端的带宽消耗；客户可以节省带宽费用，控制带宽的需求的增长并更易于管理。
2、客户端缓存生效的常见流程
服务器收到请求时，会在200 OK中回送该资源的Last-Modified和ETag头，客户端将该资源保存在cache中，并记录这两个属性。
当客户端需要发送相同的请求时，会在请求中携带If-Modified-Since和If-None-Match两个头。
两个头的值分别是响应中Last-Modified和ETag头的值。服务器通过这两个头判断本地资源未发生变化，客户端不需要重新下载，返回304响应。
3、Web缓存机制
HTTP/1.1中缓存的目的是为了在很多情况下减少发送请求，同时在许多情况下可以不需要发送完整响应。前者减少了网络回路的数量；
HTTP利用一个“过期（expiration）”机制来为此目的。后者减少了网络应用的带宽；HTTP用“验证（validation）”机制来为此目的。

HTTP定义了3种缓存机制：
1）Freshness：允许一个回应消息可以在源服务器不被重新检查，并且可以由服务器和客户端来控制。
             例如，Expires回应头给了一个文档不可用的时间。Cache-Control中的max-age标识指明了缓存的最长时间；
2）Validation：用来检查以一个缓存的回应是否仍然可用。例如，如果一个回应有一个Last-Modified回应头，
               缓存能够使用If-Modified-Since来判断是否已改变，以便判断根据情况发送请求；
3）Invalidation：在另一个请求通过缓存的时候，常常有一个副作用。例如，如果一个URL关联到一个缓存回应，
                但是其后跟着POST、PUT和DELETE的请求的话，缓存就会过期。
````
###### 断点续传的实现原理
```
HTTP协议的GET方法，支持只请求某个资源的某一部分；
206 Partial Content 部分内容响应；
Range 请求的资源范围；
Content-Range 响应的资源范围；
在连接断开重连时，客户端只请求该资源未下载的部分，而不是重新请求整个资源，来实现断点续传。
分块请求资源实例：
Eg1：Range: bytes=306302- ：请求这个资源从306302个字节到末尾的部分；
Eg2：Content-Range: bytes 306302-604047/604048：响应中指示携带的是该资源的第306302-604047的字节，该资源共604048个字节；
客户端通过并发的请求相同资源的不同片段，来实现对某个资源的并发分块下载。从而达到快速下载的目的。目前流行的FlashGet和迅雷基本都是这个原理。
```
###### 多线程下载的原理
```
下载工具开启多个发出HTTP请求的线程；
每个http请求只请求资源文件的一部分：Content-Range: bytes 20000-40000/47000；
合并每个线程下载的文件。
```



######Socket原理
流套接字（streamsocket） ：基于 TCP协议，采用 流的方式 提供可靠的字节流服务\
数据报套接字(datagramsocket)：基于 UDP协议，采用 数据报文 提供数据打包发送的服务

######Socket 与 Http 对比
```
Socket属于传输层，因为 TCP / IP协议属于传输层，解决的是数据如何在网络中传输的问题\
HTTP协议 属于 应用层，解决的是如何包装数据\
1.Socket不是一种协议，而是一个编程调用接口（API），属于传输层（主要解决数据如何在网络中传输）\
2.即：通过Socket，我们才能在Andorid平台上通过 TCP/IP协议进行开发\
3.对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信\
```
######TCP三次握手
首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。
Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。
````
Client客户端A   Server服务端B
总结三次握手过程：

第一次握手：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；
第二次握手：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，
            并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；
第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，
            并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，
            完成三次握手，随后Client和Server就可以开始传输数据。

为什么A还要发送一次确认呢？可以二次握手吗？
答：主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误
````
######为什么连接的时候是三次握手，关闭的时候却是四次握手？
```
答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。
但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。
只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
```
######为什么A在TIME-WAIT状态必须等待2MSL的时间？
````
MSL最长报文段寿命Maximum Segment Lifetime，MSL=2
1.保证A发送的最后一个ACK报文段能够到达B。
2.防止“已失效的连接请求报文段”出现在本连接中。

1）这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，
而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，
若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，
则B无法正常进入到CLOSED状态。
2）A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。
````

######为什么TCP是可靠的，UDP早不可靠的?为什么UDP比TCP快?
TCP/IP协议高，因为其拥有三次握手双向机制，这一机制保证校验了数据，保证了他的可靠性。
UDP就没有了，udp信息发出后,不验证是否到达对方,所以不可靠。
但是就速度来说，还是UDP协议更高，毕竟其无需重复返回验证，只是一次性的


######tcp的阻塞和超时处理机制等等
########TIME_WAIT 

time_wait状态产生的原因\
1）为实现TCP全双工连接的可靠释放\
2）为使旧的数据包在网络因过期而消失\

time_wait状态如何避免\
首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。\
在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。

######流量控制，拥塞控制 滑动窗口
```
所谓流量控制，主要是接收方传递信息给发送方，使其不要发送数据太快，是一种端到端的控制\

网络中的链路容量和交换结点中的缓存和处理机都有着工作的极限，当网络的需求超过它们的工作极限时，就出现了拥塞。
拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载

滑动窗口协议
1. “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”；
2. “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”
```

######Https的工作流程，原理
```
通过安全协议如SSL/TLS 来保证数据传输, SSL和TLS都是基于非对称加密算法，而RSA算法是非对称加密算法中的佼佼者。
Https是一种基于SSL/TLS的Http协议，所有的http数据都是在SSL/TLS协议封装之上传输的。

Https协议在Http协议的基础上，添加了SSL/TLS握手以及数据加密传输，也属于应用层协议。
——>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。
——>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS运行在TCP之上。所有传输的内容都经过加密,
    加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。
TLS/SSL中使用了非对称加密，对称加密以及HASH算法。
```

######https了解多少
HTTPS(全称：Hyper Text Transfer Protocol over Secure Socket Layer)，
是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
######HTTPS与HTTP的一些区别
```
HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。\
HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。\
HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\
HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。
```
######推送心跳包是TCP包还是UDP包或者HTTP包
```
心跳包的实现是调用了socket.sendUrgentData(0xFF)这句代码实现的，所以，当然是TCP包。
7 Http和Https的区别？
1）Https是ssl加密传输，Http是明文传输
2）Https是使用端口443，而Http使用80 
3）HttpsSSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比Http协议安全
4）Https协议需要到CA申请证书
```
######HttpClient和HttpURLConnection的区别 
在Android 2.2版本之前，HttpClient拥有较少的bug，因此使用它是最好的选择。
而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小

######HTTP1.0与2.0的区别
```
新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，
        要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，
        每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，
        HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。

或者下面的说法

HTTP/2采用二进制格式而非文本格式
HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行
使用报头压缩，HTTP/2降低了开销
HTTP/2让服务器可以将响应主动“推送”到客户端缓存中
```
######HTTP 2.0 原理详细分析
```
HTTP/2 的目的是通过支持请求与响应的多路复用来较少延迟，通过压缩HTTPS首部字段将协议开销降低，同时增加请求优先级和服务器端推送的支持。 
1. 二进制分帧层
二进制分帧层，是HTTP 2.0性能增强的核心。 
HTTP 1.x在应用层以纯文本的形式进行通信，而HTTP 2.0将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。
这样，客户端和服务端都需要引入新的二进制编码和解码的机制。 
    1.1 帧（frame）
    HTTP 2.0通信的最小单位，包括帧首部、流标识符、优先值和帧净荷等。
    1.2 消息（message）
    消息是指逻辑上的HTTP消息（请求/响应）。一系列数据帧组成了一个完整的消息。比如一系列DATA帧和一个HEADERS帧组成了请求消息
    1.3 流（stream）
    流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。 
    所有HTTP 2. 0 通信都在一个TCP连接上完成， 这个连接可以承载任意数量的双向数据流Stream。 相应地， 每个数据流以 消息的形式发送， 而消息由一 或多个帧组成， 
    这些帧可以乱序发送， 然后根据每个帧首部的流标识符重新组装
2. 多路复用共享连接
    基于二进制分帧层，HTTP 2.0可以在共享TCP连接的基础上，同时发送请求和响应。HTTP消息被分解为独立的帧，而不破坏消息本身的语义，
    交错发送出去，最后在另一端根据流ID和首部将它们重新组合起来。 
    例如：
            客户端向服务度发起三个图片请求/image1.jpg，/image2.jpg，/image3.jpg。 
            HTTP 1.x发起请求是串行的，image1返回后才能再发起image2，image2返回后才能再发起image3。 
            HTTP 2.0建立一条TCP连接后，并行传输着3个数据流，客户端向服务端乱序发送stream1~3的一系列的DATA帧，
            与此同时，服务端已经在返回stream 1的DATA帧 
    -->性能对比
        高下立见。HTTP 2.0成功解决了HTTP 1.x的队首阻塞问题（TCP层的阻塞仍无法解决），
        同时，也不需要通过pipeline机制多条TCP连接来实现并行请求与响应。减少了TCP连接数对服务器性能也有很大的提升。
3. 请求优先级
    流可以带有一个31bit的优先级：
    0 ：表示最高优先级
    2^31 - 1 ：表示最低优先级
    客户端明确指定优先级，服务端可以根据这个优先级作为依据交互数据，比如客户端优先级设置为.css>.js>.jpg
4. 服务端推送
    HTTP 2.0增加了服务端推送功能，服务端可以根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。
5. 首部压缩
    HTTP 1.x每一次通信（请求/响应）都会携带首部信息用于描述资源属性。
    HTTP 2.0在客户端和服务端之间使用“首部表”来跟踪和存储之前发送的键-值对。首部表在连接过程中始终存在，
    新增的键-值对会更新到表尾，因此，不需要每次通信都需要再携带首部。 
6. 一个完整的HTTP 2.0通信过程
    考虑一个问题，客户端如何知道服务端是否支持HTTP 2.0？是否支持对二进制分帧层的编码和解码？
    所以，在两端使用HTTP 2.0通信之前，必然存在协议协商的过程
```
######http的状态响应码
````
常用响应：

200 OK                        //客户端请求成功
400 Bad Request               //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden                 //服务器收到请求，但是拒绝提供服务
404 Not Found                 //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error     //服务器发生不可预期的错误
503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常



1**(信息类)：表示接收到请求并且继续处理
100——客户必须继续发出请求
101——客户要求服务器根据请求转换HTTP协议版本

2**(响应成功)：表示动作被成功接收、理解和接受
200——表明该请求被成功地完成，所请求的资源发送回客户端
201——提示知道新文件的URL
202——接受和处理、但处理未完成
...

3**(重定向类)：为了完成指定的动作，必须接受进一步处理
300——请求的资源可在多处得到
301——本网页被永久性转移到另一个URL
302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，
      新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。
...
4**(客户端错误类)：请求包含错误语法或不能正确执行
400——客户端请求有语法错误，不能被服务器所理解
401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
    HTTP 401.1 - 未授权：登录失败
    　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败
    　　HTTP 401.3 - ACL 禁止访问资源
    　　HTTP 401.4 - 未授权：授权被筛选器拒绝
    HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败
402——保留有效ChargeTo头响应
403——禁止访问，服务器收到请求，但是拒绝提供服务
HTTP 403.1 禁止访问：禁止可执行访问
　　HTTP 403.2 - 禁止访问：禁止读访问
　　HTTP 403.3 - 禁止访问：禁止写访问
    HTTP 403.4 - 禁止访问：要求 SSL
　　HTTP 403.5 - 禁止访问：要求 SSL 128
　　HTTP 403.6 - 禁止访问：IP 地址被拒绝
    ..........
404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL

5**(服务端错误类)：服务器不能正确执行一个正确的请求
HTTP 500 - 服务器遇到错误，无法完成请求
　　HTTP 500.100 - 内部服务器错误 - ASP 错误
　　HTTP 500-11 服务器关闭
　　HTTP 500-12 应用程序重新启动
　　HTTP 500-13 - 服务器太忙
　　HTTP 500-14 - 应用程序无效
　　HTTP 500-15 - 不允许请求 global.asa
　　Error 501 - 未实现
HTTP 502 - 网关错误
HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常

````
######谈谈对Volley的理解

######HttpUrlConnection 和 okhttp关系



