#JVM
#####字符串常量池
```
面试题：String str4 = new String(“abc”) 创建多少个对象？
1.在常量池中查找是否有“abc”对象
有则返回对应的引用实例
没有则创建对应的实例对象
2.在堆中 new 一个 String("abc") 对象
3.将对象地址赋值给str4,创建一个引用



String str1 = new String("A"+"B") ; 会创建多少个对象? 
字符串常量池："A","B","AB" : 3个

堆：new String("AB") ：1个

引用： str1 ：1个

总共 ： 5个
String str2 = new String("ABC") + "ABC" ; 会创建多少个对象?
字符串常量池："ABC" : 1个
堆：new String("ABC") ：1个
引用： str2 ：1个
总共 ： 3个

```
#####字符串连接有几种方式，它们之间有什么不同等问题；要不就是给一段代码问创建了几个对象
```
创建字符串对象的几种形式：

（1）通过new方式如String s = new String("iByteCode")及string.intern()方法
    对于通过new方式创建的String对象，每次都会在Heap上创建一个新的实例，但是对于字符串字面量的形式，
        只有当字符串常量池中不存在相同对象时才会创建

（2）通过字面量的形式如String s = "aaaaa"
    相当于第一种方式中的字面量部分。
（3）字面量+字面量如String s = "bbbb" + "ccccc"
    
（4）字面量+变量如String s1 = "dddd";String s = "eeeee"+s1
        JVM里面创建了两个字符串字面量dddd和 eeeee 调用StringBuilder对字符串进行连接

```

#####栈和堆的区别 

#####GC怎么知道一个对象要被回收， GC Root 




#####强引用，软引用，弱引用，虚引用 




#####类加载过程 
````
类加载的过程主要分为三个部分：
加载
链接
初始化
而链接又可以细分为三个小部分：
验证
准备
解析



加载
简单来说，加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。
这里有两个重点：
字节码来源。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译
类加载器。一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。
注：为什么会有自定义类加载器？

一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。
另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。
验证
主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。

包括对于文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？

对于元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？

对于字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。

对于符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？

准备
主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值。

特别需要注意，初值，不是代码中具体写的初始化的值，而是Java虚拟机根据不同变量类型的默认初始值。

比如8种基本类型的初值，默认为0；引用类型的初值则为null；常量的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456

解析
将常量池内的符号引用替换为直接引用的过程。

两个重点：

符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。
直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量
举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。

在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。

初始化
这个阶段主要是对类变量初始化，是执行类构造器的过程。

换句话说，只对static修饰的变量或语句进行初始化。

如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。

如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。


````

#####在项目中哪里使用过JVM的知识

#####Dalvik虚拟机和JVM虚拟机的区别

Dalvik 基于寄存器，而 JVM 基于栈。基于寄存器的虚拟机对于更大的程序来说，在它们编译的时候，花费的时间更短。
Dalvik执行.dex格式的字节码，而JVM执行.class格式的字节码
````
千万别说基于寄存器的Dalvik比基于堆栈的jvm运行速度快
Dalvik虚拟机与Java虚拟机的最显著区别是它们分别具有不同的类文件格式以及指令集。
Dalvik虚拟机使用的是dex(Dalvik Executable)格式的类文件，而Java虚拟机使用的是class格式的类文件。一个dex文件可以包含若干个类，
而一个class文件只包括一个类。由于一个dex文件可以包含若干个类，因此它就可以将各个类中重复的字符串和其它常数只保存一次，从而节省了空间，
这样就适合在内存和处理器速度有限的手机系统中使用。一般来说，包含有相同类的未压缩dex文件稍小于一个已经压缩的jar文件。Dalvik虚拟机使用的指令是基于寄存器的，
而 Java虚拟机使用的指令集是基于堆栈的。基于堆栈的指令很紧凑，例如，Java虚拟机使用的指令只占一个字节，因而称为字节码。
基于寄存器的指令由于需要指定源地址和目标地址，因此需要占用更多的指令空间，例如，Dalvik虚拟机的某些指令需要占用两个字节。
基于堆栈和基于寄存器的指令集各有优劣，一般而言，执行同样的功能，前者需要更多的指令(主要是load和store指令)，
而后者需要更多的指令空间。需要更多指令意味着要多占用CPU时间，而需要更多指令空间意味着数据缓冲(d-cache)更易失效
````


####JVM线程
在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。
因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实例就是在操作系统中启动了一个进程。

####介绍垃圾回收机制
标记回收法：遍历对象图并且记录可到达的对象，以便删除不可到达的对象，一般使用单线程工作并且可能产生内存碎片
标记-压缩回收法：前期与第一种方法相同，只是多了一步，将所有的存活对象压缩到内存的一端，这样内存碎片就可以合成一大块可再利用的内存区域，提高了内存利用率
复制回收法：把现有内存空间分成两部分，gc运行时，它把可到达对象复制到另一半空间，再清空正在使用的空间的全部对象。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。
分代回收发：把内存空间分为两个或者多个域，如年轻代和老年代，年轻代的特点是对象会很快被回收，因此在年轻代使用效率比较高的算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老年的内存空间，老年代则采取标记-压缩算法


######  JVM GC
1. 内存模型以及分区，需要详细到每个区放什么。 
2. 堆里面的分区：Eden，survival from to，老年代，各自的特点。 
3. 对象创建方法，对象的内存分配，对象的访问定位。 
4. GC的两种判定方法：引用计数与引用链。 
5. GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？ 
6. GC收集器有哪些？CMS收集器与G1收集器的特点。 
7. Minor GC与Full GC分别在什么时候发生？ 
8. 几种常用的内存调试工具：jmap、jstack、jconsole。 
9. 类加载的五个过程：加载、验证、准备、解析、初始化。 










