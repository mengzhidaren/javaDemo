```
1、单一职责原则   
总结：一个类只承担一个职责
2、开放封闭原则
总结：对软件实体的改动，最好用扩展而非修改的方式。
3、里式替换原则
总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。
4、最少知识原则
总结：一定要做到：低耦合、高内聚。
5、接口隔离原则
总结：不要对外暴露没有实际意义的接口。
6、依赖倒置原则
总结：面向接口编程，提取出事务的本质和共性。

将六大原则的英文首字母拼在一起就是SOLID（稳定的），所以也称之为SOLID原则。

创建型模式（5种）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式（8种）：适配器模式,桥接模式,过滤器模式,组合模式,装饰器模式,外观模式,享元模式（Flyweight Pattern）代理模式（Proxy Pattern）

行为型模式（12种）：

--------------------------------------------创建型模式------------------------------------------------------
------------这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。-------
------------这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活------------------------------------
原型模式（Prototype Pattern）
实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。clone()
例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用

建造者模式（Builder Pattern）
使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

工厂模式（Factory Pattern）  是 Java 中最常用的设计模式之一
通过使用一个共同的接口来指向新创建的对象

抽象工厂模式（Abstract Factory Pattern）
是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

单例模式（Singleton Pattern）
单例
--------------------------------------------结构型模式------------------------------------------------------
-----------这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式-----------
适配器模式（Adapter Pattern）
	是作为两个不兼容的接口之间的桥梁。它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能
桥接模式（Bridge）
	是用于把抽象化与实现化解耦，使得二者可以独立变化。 它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）<<<<<======
	这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。它结合多个标准来获得单一标准。
组合模式（Composite Pattern），又叫部分整体模式，
	用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。它创建了对象组的树形结构。
装饰器模式（Decorator Pattern）
	允许向一个现有的对象添加新的功能，同时又不改变其结构。，它是作为现有的类的一个包装。
	这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。
外观模式（Facade Pattern）
	隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。它向现有的系统添加一个接口，来隐藏系统的复杂性。
	这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。
享元模式（Flyweight Pattern）
	主要用于减少创建对象的数量，以减少内存占用和提高性能。它提供了减少对象数量从而改善应用所需的对象结构的方式。
	享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象
代理模式（Proxy Pattern）
	一个类代表另一个类的功能
--------------------------------------------行为型模式------------------------------------------------------
-------------------------------这些设计模式特别关注对象之间的通信--------------------------------------------
责任链模式（Chain of Responsibility Pattern）
	为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦
	在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
命令模式（Command Pattern）
	命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。
	        调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令
解释器模式（Interpreter Pattern）
	解释器模提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。
	        这种模式被用在 SQL 解析、符号处理引擎等。
迭代器模式（Iterator Pattern）
	
中介者模式（Mediator Pattern）
	中介者模式是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护
备忘录模式（Memento Pattern）
	保存一个对象的某个状态，以便在适当的时候恢复对象
观察者模式（Observer Pattern）
	当对象间存在一对多关系时，则使用观察者模式。比如，当一个对象被修改时，则会自动通知它的依赖对象
状态模式（State Pattern）
	在状态模式中，类的行为是基于它的状态改变的。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象
空对象模式（Null Object Pattern）
	在空对象模式中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。
	        这样的 Null 对象也可以在数据不可用的时候提供默认的行为。
	在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，
	        该空对象类将无缝地使用在需要检查空值的地方
策略模式（Strategy Pattern）
	在策略模式中，一个类的行为或其算法可以在运行时更改
	在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。
模板模式（Template Pattern）
	在模板模式中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式
访问者模式（Visitor Pattern）
	在访问者模式中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。
	根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。






```